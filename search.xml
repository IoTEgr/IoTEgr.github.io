<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>7-5 哈夫曼树 （20分）</title>
      <link href="/2024/10/18/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
      <url>/2024/10/18/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>​ 编写一个哈夫曼编码译码程序。针对一段文本，根据文本中字符出现频率构造哈夫曼树，给出每个字符的哈夫曼编码，并进行译码，计算编码前后文本大小。<br>为确保构建的哈夫曼树唯一，本题做如下限定：</p><p>​ 1.选择根结点权值最小的两棵二叉树时，选取权值较小者作为左子树。<br>​ 2.若多棵二叉树根结点权值相等，则先生成的作为左子树，后生成的作为右子树，具体来说：i) 对于单结点二叉树，优先选择根结点对应字母在文本中最先出现者，如文本为 cba，三个字母均出现 1 次，但 c 在文本中最先出现，b 第二出现，故则选择 c 作为左子树，b 作为右子树。ii) 对于非单结点二叉树，先生成的二叉树作为左子树，后生成的二叉树作为右子树。iii. 若单结点和非单结点二叉树根结点权值相等，优先选择单结点二叉树。<br>​ 3.生成哈夫曼编码时，哈夫曼树左分支标记为 0，右分支标记为 1。</p><h3 id="输入格式："><a href="#输入格式：" class="headerlink" title="输入格式："></a>输入格式：</h3><p>​ 输入为 3 行。第 1 行为一个字符串，包含不超过 5000 个字符，至少包含两个不同的字符，每个字符为 a-z 的小写字母。第 2、3 行为两个由 0、1 组成的字符串，表示待译码的哈夫曼编码。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>​ 输出第一行为用空格间隔的 2 个整数，分别为压缩前后文本大小，以字节为单位，一个字符占 1 字节，8 个二进制位占 1 字节，若压缩后文本不足 8 位，则按 1 字节算。输出从第二行开始，每行为 1 个字符的哈夫曼编码，按各字符在文本中出现次数递增顺序输出，若多个字符出现次数相同，则按其在文本出现先后排列。每行格式为“字母:编码”。最后两行为两行字符串，表示译码结果，若译码失败，则输出 INVALID。</p><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cbaxyyzz</span><br><span class="line"><span class="number">0100</span></span><br><span class="line"><span class="number">011</span></span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span> <span class="number">3</span></span><br><span class="line">c:<span class="number">100</span></span><br><span class="line">b:<span class="number">101</span></span><br><span class="line">a:<span class="number">110</span></span><br><span class="line">x:<span class="number">111</span></span><br><span class="line">y:<span class="number">00</span></span><br><span class="line">z:<span class="number">01</span></span><br><span class="line">zy</span><br><span class="line">INVALID</span><br></pre></td></tr></table></figure><h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>先用<a href="https://so.csdn.net/so/search?q=优先队列&amp;spm=1001.2101.3001.7020">优先队列</a>建树，然后深搜探索出每个字符的编码，再对比特流进行译码即可。</p><h3 id="AC-代码："><a href="#AC-代码：" class="headerlink" title="AC 代码："></a>AC 代码：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="type">char</span> date;<span class="comment">//记录字符</span></span><br><span class="line"><span class="type">int</span> HZ;<span class="comment">//记录频率</span></span><br><span class="line"><span class="type">int</span> qz;<span class="comment">//记录优先值</span></span><br><span class="line">node* left;<span class="comment">//左子树</span></span><br><span class="line">node* right;<span class="comment">//右子树</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;<span class="comment">//优先队列排序规则</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> node* x,<span class="type">const</span> node* y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x-&gt;HZ!=y-&gt;HZ)<span class="keyword">return</span> x-&gt;HZ&gt;y-&gt;HZ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> x-&gt;qz&gt;y-&gt;qz;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">string x,y,z;</span><br><span class="line"><span class="type">int</span> bj,wpl=<span class="number">0</span>,jh;</span><br><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;mp,yxj;<span class="comment">//记录频率和优先值</span></span><br><span class="line">vector&lt;<span class="type">char</span>&gt;ym;<span class="comment">//记录译出的码</span></span><br><span class="line">priority_queue&lt;node*,vector&lt;node*&gt;,cmp&gt;q,rnm;</span><br><span class="line">map&lt;<span class="type">char</span>,vector&lt;<span class="type">int</span>&gt; &gt;bm;<span class="comment">//记录各字符编码</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(node* BT)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(BT)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">islower</span>(BT-&gt;date))&#123;</span><br><span class="line">bm[BT-&gt;date]=v;</span><br><span class="line">&#125;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">dfs</span>(BT-&gt;left);</span><br><span class="line">v.<span class="built_in">pop_back</span>();</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">dfs</span>(BT-&gt;right);</span><br><span class="line">v.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ym</span><span class="params">(string x)</span></span>&#123;<span class="comment">//译码函数</span></span><br><span class="line">ym.<span class="built_in">clear</span>();</span><br><span class="line">node* t=<span class="keyword">new</span> node;</span><br><span class="line">t=q.<span class="built_in">top</span>();</span><br><span class="line">jh=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(x[i]==<span class="string">&#x27;0&#x27;</span>)t=t-&gt;left;</span><br><span class="line"><span class="keyword">else</span> t=t-&gt;right;</span><br><span class="line"><span class="keyword">if</span>((i==(x.<span class="built_in">size</span>()<span class="number">-1</span>))&amp;&amp;<span class="built_in">isupper</span>(t-&gt;date))jh=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">islower</span>(t-&gt;date))&#123;</span><br><span class="line">ym.<span class="built_in">push_back</span>(t-&gt;date);</span><br><span class="line">t=q.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(jh)for_each(ym.<span class="built_in">begin</span>(),ym.<span class="built_in">end</span>(),[](<span class="type">char</span> x)&#123;cout&lt;&lt;x;&#125;);</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;INVALID&quot;</span>;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> k:x)&#123;</span><br><span class="line">mp[k]++;</span><br><span class="line"><span class="keyword">if</span>(yxj[k]==<span class="number">0</span>)yxj[k]=bj++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> k:mp)&#123;</span><br><span class="line">node* t=<span class="keyword">new</span> node;</span><br><span class="line">t-&gt;date=k.first;</span><br><span class="line">t-&gt;HZ=k.second;</span><br><span class="line">t-&gt;qz=yxj[k.first];</span><br><span class="line">t-&gt;left=t-&gt;right=<span class="literal">nullptr</span>;</span><br><span class="line">q.<span class="built_in">push</span>(t);</span><br><span class="line">rnm.<span class="built_in">push</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>()!=<span class="number">1</span>)&#123;<span class="comment">//构建哈夫曼树</span></span><br><span class="line">node* a=<span class="keyword">new</span> node;</span><br><span class="line">a=q.<span class="built_in">top</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">node* b=<span class="keyword">new</span> node;</span><br><span class="line">b=q.<span class="built_in">top</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">node* t=<span class="keyword">new</span> node;</span><br><span class="line">t-&gt;date=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">t-&gt;qz=bj++;</span><br><span class="line">t-&gt;HZ=a-&gt;HZ+b-&gt;HZ;</span><br><span class="line">t-&gt;left=a;</span><br><span class="line">t-&gt;right=b;</span><br><span class="line">q.<span class="built_in">push</span>(t);</span><br><span class="line">wpl+=t-&gt;HZ;</span><br><span class="line">&#125;</span><br><span class="line">    cout&lt;&lt;x.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="type">int</span> e=wpl/<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span>(e*<span class="number">8</span>&lt;wpl)e++;</span><br><span class="line">    cout&lt;&lt;e&lt;&lt;endl;</span><br><span class="line"><span class="built_in">dfs</span>(q.<span class="built_in">top</span>());</span><br><span class="line"><span class="keyword">while</span>(rnm.<span class="built_in">size</span>())&#123;</span><br><span class="line"><span class="type">char</span> k=rnm.<span class="built_in">top</span>()-&gt;date;</span><br><span class="line">cout&lt;&lt;k&lt;&lt;<span class="string">&quot;:&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> r:bm[k])&#123;</span><br><span class="line">cout&lt;&lt;r;</span><br><span class="line">&#125;</span><br><span class="line">rnm.<span class="built_in">pop</span>();</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">ym</span>(y);</span><br><span class="line"><span class="built_in">ym</span>(z);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>传染链</title>
      <link href="/2020/05/10/%E4%BC%A0%E6%9F%93%E9%93%BE/"/>
      <url>/2020/05/10/%E4%BC%A0%E6%9F%93%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h1 id="传染链"><a href="#传染链" class="headerlink" title="传染链"></a>传染链</h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有 $n$ 个城市，城市之间有 $m$ 条双向道路。每个城市有一个初始状态，$0$ 表示未感染，$1$ 表示已感染。现在要求你选择一个城市，使得感染状态为 $1$ 的城市数量最多。</p><h2 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h2>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 图论 </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
