<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>180°舵机如何控制？</title>
      <link href="/2024/10/19/%E8%88%B5%E6%9C%BA/"/>
      <url>/2024/10/19/%E8%88%B5%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<p>180° 舵机最常见的是 SG90 舵机，用的也最多，非常便宜，某多多 5.6 块就可以买到一个，大概长这样：<br><img src="https://images-1323170699.cos.ap-guangzhou.myqcloud.com/%E8%88%B5%E6%9C%BA.jpeg?imageSlim" alt="舵机"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>大二刚学单片机，觉得单片机很厉害，然后就想做一个宿舍智能开门装置。然后我就想其中最主要的问题是解决拉锁栓，拉锁栓可以用一个动力装置来完成，只要找到这个装置，那么就可以做出来了，然后我就想尽办法找这个装置。功夫不负有心人，经过几天的寻找，终于在某个视频中找到了他的身影，得知这个装置就叫做舵机。</p><h2 id="控制原理探索"><a href="#控制原理探索" class="headerlink" title="控制原理探索"></a>控制原理探索</h2><p>知道了它是谁，那么下一步就是要学会控制它，然后我就找了一些帖子来了解如何去控制舵机。大多看到的是这样的解释：</p><p>舵机的控制一般需要一个 20ms 左右的时基脉冲，该脉冲的高电平部分一般为 0.5ms~2.5ms 范围内的角度控制脉冲部分。以 180 度角度伺服为例，那么对应的控制关系是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">0.5</span>ms ---------- <span class="number">0</span> 度；</span><br><span class="line"></span><br><span class="line"><span class="number">1.0</span>ms ---------- <span class="number">45</span> 度；</span><br><span class="line"></span><br><span class="line"><span class="number">1.5</span>ms ---------- <span class="number">90</span> 度；</span><br><span class="line"></span><br><span class="line"><span class="number">2.0</span>ms ---------- <span class="number">135</span> 度；</span><br><span class="line"></span><br><span class="line"><span class="number">2.5</span>ms ---------- <span class="number">180</span> 度；</span><br></pre></td></tr></table></figure><p>起初我以为在 20ms 的时基脉冲中，当高电平有 1.0ms 时，它就会在当前位置正向转动 45°，如果再给它一个这样的 pwm，它还会再正向转 45°。然后我就在想，用舵机把锁栓拉过去后，总不能一直拉着吧，然后我就想如何控制舵机反向旋转再把锁栓拉回去。但我发现搜不到舵机倒转的教程，我就很疑惑。经过一番研究，我终于知道怎么控制了。原来舵机会根据 pwm 的高电平时长来转动一定角度，如果目前正处于这个角度，那它就不会转动了，比如：现在舵机臂在 90° 位置，如果你的 pwm 高电平时间为 1.0ms，那么舵机就会逆时针转 45°，然后停在 45° 位置，如果高电平时间为 2.0ms，那么舵机就会顺时针转 45°，然后停在 135° 位置。哈哈，原来如此，终于弄明白了，在此纪录一下，也顺便引领一下和我一样的小朋友回到正轨。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>捎带说一下，舵机有三根线，红色接电源，棕色接地，橙色接 pwm 信号 。一般买回来的舵机三根线都是连接在一起的，建议把他们分开，不然不好和单片机连接，可以直接把头剪掉，然后每一根线都接一根杜邦线母头就可以了。还有，360° 舵机的控制原理可不跟 180° 一样，360° 舵机是根据 pwm 高电平时长来改变转速和方向的，在高电平时长为 0.5ms~1.5ms 时：舵机正转，高电平时间越短，转速越快（尽量不接近 1.5ms，否则有可能不转）；在 1.5ms（1.6ms、1.4ms 等）:停止转动，即速度为 0；在 1.5ms~2.5ms 时:舵机反转，时间越长，转速越快；360° 舵机 pwm 高电平时间尽量接近 0.5ms 与 2.5ms，否则有可能不转,而且他会一直转，不好控制，所以还是 180° 好用些，建议买 180° 的。</p>]]></content>
      
      
      <categories>
          
          <category> 各种模块 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>城市间紧急救援 7-3</title>
      <link href="/2024/10/19/%E5%9F%8E%E5%B8%82%E9%97%B4%E7%B4%A7%E6%80%A5%E6%95%91%E6%8F%B4/"/>
      <url>/2024/10/19/%E5%9F%8E%E5%B8%82%E9%97%B4%E7%B4%A7%E6%80%A5%E6%95%91%E6%8F%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>作为一个城市的应急救援队伍的负责人，你有一张特殊的全国地图。在地图上显示有多个分散的城市和一些连接城市的快速道路。每个城市的救援队数量和每一条连接两个城市的快速道路长度都标在地图上。当其他城市有紧急求助电话给你的时候，你的任务是带领你的救援队尽快赶往事发地，同时，一路上召集尽可能多的救援队。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入第一行给出 4 个正整数 N、M、S、D，其中 N（2≤N≤500）是城市的个数，顺便假设城市的编号为 0 ~ (N−1)；M 是快速道路的条数；S 是出发地的城市编号；D 是目的地的城市编号。</p><p>第二行给出 N 个正整数，其中第 i 个数是第 i 个城市的救援队的数目，数字间以空格分隔。随后的 M 行中，每行给出一条快速道路的信息，分别是：城市 1、城市 2、快速道路的长度，中间用空格分开，数字均为整数且不超过 500。输入保证救援可行且最优解唯一。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>第一行输出最短路径的条数和能够召集的最多的救援队数量。第二行输出从 S 到 D 的路径中经过的城市编号。数字间以空格分隔，输出结尾不能有多余空格。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">0</span> <span class="number">3</span></span><br><span class="line"><span class="number">20</span> <span class="number">30</span> <span class="number">40</span> <span class="number">10</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">2</span></span><br><span class="line"><span class="number">0</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">2</span></span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span> <span class="number">60</span></span><br><span class="line"><span class="number">0</span> <span class="number">1</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>链式前向星存图 Dijkstra 算法求最短路的同时求收集最多的路径 每次记录父亲结点 最后递归输出路径即可，最主要的是路径个数的求法，我们可以找一个数组来记录到达每个结点的路径条数，当距离更新的时候，此结点的路径个数就等于上一个结点的路径个数，当距离相等时，到达此结点最短路径的个数应该加上 上一个结点的；</p><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> fw=<span class="number">1e6</span><span class="number">+10</span>;</span><br><span class="line"><span class="keyword">using</span> pii=pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;;<span class="comment">//让pii等于pair类型</span></span><br><span class="line"><span class="type">int</span> e[fw],ne[fw],h[fw],w[fw],rs[fw],xb,n,m,s,d,bj[fw],jl[fw],zrs[fw],pre[fw],road[fw];</span><br><span class="line"><span class="comment">//e数组存边的终点，ne数组存下一个点的下标，h数组存头结点的下标，w数组存边的长度</span></span><br><span class="line"><span class="comment">//rs数组存每个城市的人数，xb存e数组用到了哪里，n,m,s,d与题目变量对应，bj数组标记该城市是否</span></span><br><span class="line"><span class="comment">//访问过，jl数组存该城市距离起点的最短距离，zrs数组存当前城市到起点收集到的人数</span></span><br><span class="line"><span class="comment">//pre数组存储该结点的父亲结点，road数组存储到达此结点的路径个数。</span></span><br><span class="line">priority_queue&lt;pii,vector&lt;pii&gt;,greater&lt;pii&gt;&gt;q;<span class="comment">//优先队列存储已经收到的结点；</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cr</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span>&#123;<span class="comment">//链式前向星插入模板</span></span><br><span class="line">e[xb]=y;<span class="comment">//记录终点</span></span><br><span class="line">w[xb]=z;<span class="comment">//记录边的长度</span></span><br><span class="line">ne[xb]=h[x];<span class="comment">//把此结点插入到x这个链表中</span></span><br><span class="line">h[x]=xb++;<span class="comment">//插入到头部</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">djstl</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">bj[x]=<span class="number">1</span>;<span class="comment">//标记为已经访问</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=h[x];i!=<span class="number">-1</span>;i=ne[i])&#123;<span class="comment">//遍历这个城市可以到达的城市</span></span><br><span class="line"><span class="type">int</span> f=e[i];<span class="comment">//获取点的编号</span></span><br><span class="line"><span class="keyword">if</span>(jl[f]&gt;jl[x]+w[i])&#123;<span class="comment">//如果经过中转距离更短就更新</span></span><br><span class="line">jl[f]=jl[x]+w[i];<span class="comment">//更新距离</span></span><br><span class="line">road[f]=road[x];<span class="comment">//路径个数等于上一个点的</span></span><br><span class="line">zrs[f]=zrs[x]+rs[f];<span class="comment">//更新人数</span></span><br><span class="line">pre[f]=x;</span><br><span class="line">q.<span class="built_in">push</span>(&#123;jl[f],f&#125;);<span class="comment">//推入优先队列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(jl[f]==jl[x]+w[i])&#123;<span class="comment">//如果距离相同 如果能收集到的人数更多就更新</span></span><br><span class="line">road[f]+=road[x];</span><br><span class="line"><span class="keyword">if</span>(zrs[f]&lt;zrs[x]+rs[f])&#123;</span><br><span class="line">zrs[f]=zrs[x]+rs[f];</span><br><span class="line">pre[f]=x;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>())&#123;<span class="comment">//寻找没访问过的点</span></span><br><span class="line"><span class="type">int</span> t=q.<span class="built_in">top</span>().second;</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">if</span>(!bj[t])&#123;</span><br><span class="line"><span class="built_in">djstl</span>(t);<span class="comment">//递归这个点</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dy</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">//路径打印函数</span></span><br><span class="line"><span class="keyword">if</span>(x==s)<span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">dy</span>(pre[x]);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="keyword">sizeof</span> h);</span><br><span class="line"><span class="built_in">memset</span>(jl,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> jl);<span class="comment">//把距离置为无穷大</span></span><br><span class="line">cin&gt;&gt;n&gt;&gt;m&gt;&gt;s&gt;&gt;d;<span class="comment">//输入城市个数，路的条数，起点，终点</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)cin&gt;&gt;rs[i];<span class="comment">//输入每个城市的人数</span></span><br><span class="line"><span class="keyword">while</span>(m--)&#123;<span class="comment">//输入边的信息</span></span><br><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line"><span class="built_in">cr</span>(a,b,c);</span><br><span class="line"><span class="built_in">cr</span>(b,a,c);</span><br><span class="line">&#125;</span><br><span class="line">jl[s]=<span class="number">0</span>;<span class="comment">//初始化距离</span></span><br><span class="line">zrs[s]=rs[s];<span class="comment">//初始化人数</span></span><br><span class="line">road[s]=<span class="number">1</span>;</span><br><span class="line">q.<span class="built_in">push</span>(&#123;<span class="number">0</span>,s&#125;);<span class="comment">//把起点推入队列</span></span><br><span class="line"><span class="built_in">djstl</span>(s);<span class="comment">//求最合适的路径</span></span><br><span class="line">cout&lt;&lt;road[d]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;zrs[d]&lt;&lt;endl;<span class="comment">//输出路径个数</span></span><br><span class="line">cout&lt;&lt;s;<span class="comment">//先输出起点</span></span><br><span class="line"><span class="built_in">dy</span>(d);<span class="comment">//打印路径</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 图论 </tag>
            
            <tag> Dijkstra算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>公路村村通 Prim算法 （链式前向星实现）</title>
      <link href="/2024/10/19/%E5%85%AC%E8%B7%AF%E6%9D%91%E6%9D%91%E9%80%9A/"/>
      <url>/2024/10/19/%E5%85%AC%E8%B7%AF%E6%9D%91%E6%9D%91%E9%80%9A/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>现有村落间道路的统计数据表中，列出了有可能建设成标准公路的若干条道路的成本，求使每个村落都有公路连通所需要的最低成本。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入数据包括城镇数目正整数 N（≤1000）和候选道路数目 M（≤3N）；随后的 M 行对应 M 条道路，每行给出 3 个正整数，分别是该条道路直接连通的两个城镇的编号以及该道路改建的预算成本。为简单起见，城镇从 1 到 N 编号。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>输出村村通需要的最低成本。如果输入数据不足以保证畅通，则输出 −1，表示需要建设更多公路。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6</span> <span class="number">15</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span> <span class="number">3</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span> <span class="number">4</span> <span class="number">7</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="number">2</span> <span class="number">5</span> <span class="number">2</span></span><br><span class="line"><span class="number">2</span> <span class="number">6</span> <span class="number">6</span></span><br><span class="line"><span class="number">3</span> <span class="number">4</span> <span class="number">6</span></span><br><span class="line"><span class="number">3</span> <span class="number">5</span> <span class="number">1</span></span><br><span class="line"><span class="number">3</span> <span class="number">6</span> <span class="number">1</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">10</span></span><br><span class="line"><span class="number">4</span> <span class="number">6</span> <span class="number">8</span></span><br><span class="line"><span class="number">5</span> <span class="number">6</span> <span class="number">3</span></span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>链式前向星存图，然后从某一个结点开始遍历整个图，每次选择已经收入囊中的结点距离他们所能到达的结点的最小权值即可。</p><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> fw=<span class="number">1e5</span><span class="number">+10</span>;</span><br><span class="line"><span class="type">int</span> e[fw],w[fw],ne[fw],h[fw],bj[fw],xb,n,m,zx,gs;<span class="comment">//e数组存储终点值，w数组存储权值，ne数组存储下一个结点的下标，h数组存储头结点下标，bj数组标记是否被访问过，xb用来存储e数组用到了哪里，zx用来存储最小总权值，gs用来存储已经收入囊中的结点个数。</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v;<span class="comment">//存储已经收入囊中的结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">cr</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">int</span> z)</span></span>&#123;<span class="comment">//链式前向星插入模板</span></span><br><span class="line">e[xb]=y;</span><br><span class="line">w[xb]=z;</span><br><span class="line">ne[xb]=h[x];</span><br><span class="line">h[x]=xb++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(gs==n<span class="number">-1</span>)&#123;<span class="comment">//如果所有结点都被访问了就直接输出即可</span></span><br><span class="line">cout&lt;&lt;zx;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">bj[x]=<span class="number">1</span>;</span><br><span class="line">v.<span class="built_in">push_back</span>(x);<span class="comment">//收入囊中</span></span><br><span class="line"><span class="type">int</span> t=<span class="number">99999999</span>,u=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> k:v)&#123;<span class="comment">//寻找最小权值的边</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=h[k];i!=<span class="number">-1</span>;i=ne[i])&#123;</span><br><span class="line"><span class="keyword">if</span>(w[i]&lt;t&amp;&amp;(!bj[e[i]]))&#123;</span><br><span class="line">t=w[i];</span><br><span class="line">u=e[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(u!=<span class="number">-1</span>)&#123;</span><br><span class="line">zx+=t;</span><br><span class="line">gs++;</span><br><span class="line"><span class="built_in">prim</span>(u);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">while</span>(m--)&#123;</span><br><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line"><span class="built_in">cr</span>(a,b,c);</span><br><span class="line"><span class="built_in">cr</span>(b,a,c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">prim</span>(n);</span><br><span class="line">cout&lt;&lt;<span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 图论 </tag>
            
            <tag> Prim算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-6 传染链 (25分）</title>
      <link href="/2024/10/19/%E4%BC%A0%E6%9F%93%E9%93%BE/"/>
      <url>/2024/10/19/%E4%BC%A0%E6%9F%93%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>某病毒可以人传人，且传染能力极强，只要与已感染该病毒的人发生接触即刻感染。<br>现给定一些感染该病毒的人员接触关系，要求你找出其中最早最长的一条传染链。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>输入在第一行中给出一个正整数 N（N≤104），即感染病毒的人员总数，从 0 到 N−1 进行编号。</p><p>随后 N 行按照编号顺序给出人员接触信息，每行按以下格式描述该人员的接触对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">k 接触人员<span class="number">1</span> …… 接触人员k</span><br></pre></td></tr></table></figure><p>其中 k 是该编号人员接触的其他人总数，后面按照时间先后给出所有接触的人员编号。题目保证传染源头有且仅有一个，且已被感染人员不会与另一个感染人员再接触。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>第一行输出从源头开始的最早最长传染链长度。</p><p>第二行输出从源头开始的最早最长传染链，编号之间以 1 个空格分隔，行首尾不得有多余空格。这里的最早最长传染链是指从源头开始的传染链上的人数最多，且被感染的时间最早。</p><p>所谓时间最早指的两个长度相等的传染链{a1,a2,…,an}和{b1,b2,…,bn}，存在 1≤k&lt;n，对于所有的 i (1≤i&lt;k)都满足 ai=bi，且 ak 被感染的时间早于 bk 被感染的时间。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">3</span> <span class="number">3</span> <span class="number">4</span> <span class="number">7</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">9</span></span><br><span class="line"><span class="number">1</span> <span class="number">6</span></span><br><span class="line"><span class="number">1</span> <span class="number">5</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">2</span> <span class="number">6</span> <span class="number">0</span></span><br><span class="line"><span class="number">1</span> <span class="number">8</span></span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span> <span class="number">3</span> <span class="number">6</span></span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先用邻接表存储图，没有出现的编号就是传染源，然后 dfs 找出路径即可 。</p><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v[<span class="number">10010</span>],jg,zj;<span class="comment">//存储图、结果序列、遍历时的临时序列</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;v[x].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">    zj.<span class="built_in">push_back</span>(v[x][i]);</span><br><span class="line">        <span class="built_in">dfs</span>(v[x][i]);</span><br><span class="line">        zj.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(zj.<span class="built_in">size</span>()&gt;jg.<span class="built_in">size</span>())jg=zj;<span class="comment">//如果找到的传染链长就记下来</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,bj[<span class="number">10010</span>];<span class="comment">//bj数组用来判断是否出现过</span></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;<span class="comment">//存储图</span></span><br><span class="line">        <span class="type">int</span> m;</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line">        <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">            <span class="type">int</span> x;</span><br><span class="line">            cin &gt;&gt; x;</span><br><span class="line">            v[i].<span class="built_in">push_back</span>(x);</span><br><span class="line">            bj[x] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> BT=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;<span class="comment">//找到传染源</span></span><br><span class="line">        <span class="keyword">if</span>(!bj[i])&#123;</span><br><span class="line">            BT = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(BT);</span><br><span class="line">    cout &lt;&lt; jg.<span class="built_in">size</span>()<span class="number">+1</span>&lt;&lt;endl&lt;&lt;BT;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> k:jg)&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;k;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 图论 </tag>
            
            <tag> dfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>7-5 哈夫曼树 （20分）</title>
      <link href="/2024/10/18/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/"/>
      <url>/2024/10/18/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>​ 编写一个哈夫曼编码译码程序。针对一段文本，根据文本中字符出现频率构造哈夫曼树，给出每个字符的哈夫曼编码，并进行译码，计算编码前后文本大小。<br>为确保构建的哈夫曼树唯一，本题做如下限定：</p><p>​ 1.选择根结点权值最小的两棵二叉树时，选取权值较小者作为左子树。<br>​ 2.若多棵二叉树根结点权值相等，则先生成的作为左子树，后生成的作为右子树，具体来说：i) 对于单结点二叉树，优先选择根结点对应字母在文本中最先出现者，如文本为 cba，三个字母均出现 1 次，但 c 在文本中最先出现，b 第二出现，故则选择 c 作为左子树，b 作为右子树。ii) 对于非单结点二叉树，先生成的二叉树作为左子树，后生成的二叉树作为右子树。iii. 若单结点和非单结点二叉树根结点权值相等，优先选择单结点二叉树。<br>​ 3.生成哈夫曼编码时，哈夫曼树左分支标记为 0，右分支标记为 1。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h3><p>​ 输入为 3 行。第 1 行为一个字符串，包含不超过 5000 个字符，至少包含两个不同的字符，每个字符为 a-z 的小写字母。第 2、3 行为两个由 0、1 组成的字符串，表示待译码的哈夫曼编码。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h3><p>​ 输出第一行为用空格间隔的 2 个整数，分别为压缩前后文本大小，以字节为单位，一个字符占 1 字节，8 个二进制位占 1 字节，若压缩后文本不足 8 位，则按 1 字节算。输出从第二行开始，每行为 1 个字符的哈夫曼编码，按各字符在文本中出现次数递增顺序输出，若多个字符出现次数相同，则按其在文本出现先后排列。每行格式为“字母:编码”。最后两行为两行字符串，表示译码结果，若译码失败，则输出 INVALID。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cbaxyyzz</span><br><span class="line"><span class="number">0100</span></span><br><span class="line"><span class="number">011</span></span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8</span> <span class="number">3</span></span><br><span class="line">c:<span class="number">100</span></span><br><span class="line">b:<span class="number">101</span></span><br><span class="line">a:<span class="number">110</span></span><br><span class="line">x:<span class="number">111</span></span><br><span class="line">y:<span class="number">00</span></span><br><span class="line">z:<span class="number">01</span></span><br><span class="line">zy</span><br><span class="line">INVALID</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>先用<a href="https://so.csdn.net/so/search?q=优先队列&amp;spm=1001.2101.3001.7020">优先队列</a>建树，然后深搜探索出每个字符的编码，再对比特流进行译码即可。</p><h3 id="AC-代码"><a href="#AC-代码" class="headerlink" title="AC 代码"></a>AC 代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line"><span class="type">char</span> date;<span class="comment">//记录字符</span></span><br><span class="line"><span class="type">int</span> HZ;<span class="comment">//记录频率</span></span><br><span class="line"><span class="type">int</span> qz;<span class="comment">//记录优先值</span></span><br><span class="line">node* left;<span class="comment">//左子树</span></span><br><span class="line">node* right;<span class="comment">//右子树</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;<span class="comment">//优先队列排序规则</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">const</span> node* x,<span class="type">const</span> node* y)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x-&gt;HZ!=y-&gt;HZ)<span class="keyword">return</span> x-&gt;HZ&gt;y-&gt;HZ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> x-&gt;qz&gt;y-&gt;qz;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">string x,y,z;</span><br><span class="line"><span class="type">int</span> bj,wpl=<span class="number">0</span>,jh;</span><br><span class="line">map&lt;<span class="type">char</span>,<span class="type">int</span>&gt;mp,yxj;<span class="comment">//记录频率和优先值</span></span><br><span class="line">vector&lt;<span class="type">char</span>&gt;ym;<span class="comment">//记录译出的码</span></span><br><span class="line">priority_queue&lt;node*,vector&lt;node*&gt;,cmp&gt;q,rnm;</span><br><span class="line">map&lt;<span class="type">char</span>,vector&lt;<span class="type">int</span>&gt; &gt;bm;<span class="comment">//记录各字符编码</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;v;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(node* BT)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(BT)&#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">islower</span>(BT-&gt;date))&#123;</span><br><span class="line">bm[BT-&gt;date]=v;</span><br><span class="line">&#125;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">dfs</span>(BT-&gt;left);</span><br><span class="line">v.<span class="built_in">pop_back</span>();</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">dfs</span>(BT-&gt;right);</span><br><span class="line">v.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ym</span><span class="params">(string x)</span></span>&#123;<span class="comment">//译码函数</span></span><br><span class="line">ym.<span class="built_in">clear</span>();</span><br><span class="line">node* t=<span class="keyword">new</span> node;</span><br><span class="line">t=q.<span class="built_in">top</span>();</span><br><span class="line">jh=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;x.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(x[i]==<span class="string">&#x27;0&#x27;</span>)t=t-&gt;left;</span><br><span class="line"><span class="keyword">else</span> t=t-&gt;right;</span><br><span class="line"><span class="keyword">if</span>((i==(x.<span class="built_in">size</span>()<span class="number">-1</span>))&amp;&amp;<span class="built_in">isupper</span>(t-&gt;date))jh=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">islower</span>(t-&gt;date))&#123;</span><br><span class="line">ym.<span class="built_in">push_back</span>(t-&gt;date);</span><br><span class="line">t=q.<span class="built_in">top</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(jh)for_each(ym.<span class="built_in">begin</span>(),ym.<span class="built_in">end</span>(),[](<span class="type">char</span> x)&#123;cout&lt;&lt;x;&#125;);</span><br><span class="line"><span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;INVALID&quot;</span>;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cin&gt;&gt;x&gt;&gt;y&gt;&gt;z;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> k:x)&#123;</span><br><span class="line">mp[k]++;</span><br><span class="line"><span class="keyword">if</span>(yxj[k]==<span class="number">0</span>)yxj[k]=bj++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> k:mp)&#123;</span><br><span class="line">node* t=<span class="keyword">new</span> node;</span><br><span class="line">t-&gt;date=k.first;</span><br><span class="line">t-&gt;HZ=k.second;</span><br><span class="line">t-&gt;qz=yxj[k.first];</span><br><span class="line">t-&gt;left=t-&gt;right=<span class="literal">nullptr</span>;</span><br><span class="line">q.<span class="built_in">push</span>(t);</span><br><span class="line">rnm.<span class="built_in">push</span>(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(q.<span class="built_in">size</span>()!=<span class="number">1</span>)&#123;<span class="comment">//构建哈夫曼树</span></span><br><span class="line">node* a=<span class="keyword">new</span> node;</span><br><span class="line">a=q.<span class="built_in">top</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">node* b=<span class="keyword">new</span> node;</span><br><span class="line">b=q.<span class="built_in">top</span>();</span><br><span class="line">q.<span class="built_in">pop</span>();</span><br><span class="line">node* t=<span class="keyword">new</span> node;</span><br><span class="line">t-&gt;date=<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">t-&gt;qz=bj++;</span><br><span class="line">t-&gt;HZ=a-&gt;HZ+b-&gt;HZ;</span><br><span class="line">t-&gt;left=a;</span><br><span class="line">t-&gt;right=b;</span><br><span class="line">q.<span class="built_in">push</span>(t);</span><br><span class="line">wpl+=t-&gt;HZ;</span><br><span class="line">&#125;</span><br><span class="line">    cout&lt;&lt;x.<span class="built_in">size</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="type">int</span> e=wpl/<span class="number">8</span>;</span><br><span class="line">    <span class="keyword">if</span>(e*<span class="number">8</span>&lt;wpl)e++;</span><br><span class="line">    cout&lt;&lt;e&lt;&lt;endl;</span><br><span class="line"><span class="built_in">dfs</span>(q.<span class="built_in">top</span>());</span><br><span class="line"><span class="keyword">while</span>(rnm.<span class="built_in">size</span>())&#123;</span><br><span class="line"><span class="type">char</span> k=rnm.<span class="built_in">top</span>()-&gt;date;</span><br><span class="line">cout&lt;&lt;k&lt;&lt;<span class="string">&quot;:&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> r:bm[k])&#123;</span><br><span class="line">cout&lt;&lt;r;</span><br><span class="line">&#125;</span><br><span class="line">rnm.<span class="built_in">pop</span>();</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">ym</span>(y);</span><br><span class="line"><span class="built_in">ym</span>(z);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 图论 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
